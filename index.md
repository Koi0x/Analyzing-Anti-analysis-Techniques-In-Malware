## Analyzing Anti-anlysis Techniques In Malware - koi0x

In this write-up, I will be diving into the anti-analysis techniques used by malware in the wild. There are many different ways this is conducted. For example, processor checks, registry key checks, running process checks, and other checks such as virtual port checks and CPUID checks. I will try to keep this write-up short and to the point, as it's easy to over-explain. These techniques are not all universally the same when it comes to their implementation in malware nor are they always implemented in every malware sample that comes across the tape. However, these are the most commonly used techniques that you will find. Let's begin.    

### Checking the CPUID

For the first anti-analysis technique, we will be looking at the CPUID checks. CPUID is an assembly-level instruction that allows for a program to pull down information regarding the current processor.  This is important for malware authors because it can provide insight into the current processor manufacturer string. This is a very common technique used for multiple reasons. For example, there are no direct API calls needed to make it work and it also is easily overlooked by researchers who are not only trying to do dynamic analysis in a virtualized/sandboxed environment but also static analysis. Now that we have the basics out of the way, let's get a deeper understanding of how this works. 

From the cyberbit post [here](https://www.cyberbit.com/blog/endpoint-security/anti-vm-and-anti-sandbox-explained/), it exaplins the following:

```markdown
This instruction is executed with EAX=1 as input, the return value describes the processors features. 
The 31st bit of ECX on a physical machine will be equal to 0. On a guest VM it will equal to 1.
```
Let's take a look at this code sample below. It is just a basic C++ program that uses inline assembly to check the value of the 31st bit in the ECX register. Remember, in an un-altered virtualized environment, this value will be equal to 1. Below the inline assembly, I added a small amount of logic to show how it might be used in a sample, but obviously, they won't just exit the program, the steps to halt the execution of the sample will be more complex.

```C++
#include <iostream>

int main()
{
    bool VmCheck = false;
    __asm {
        xor eax, eax
        inc    eax
        cpuid
        bt     ecx, 0x1f  
        jc     TrueVM
        FalseVM :
        jmp     NopInstruct
        TrueVM :
        mov    VmCheck, 0x1
        NopInstruct :
        nop
    }
    if (VmCheck == 1)
    {
        exit(0);
    }
    else
    {
        std::cout << "Device is not virtualized" << std::endl;
    }
    return 0;
}
```
Taking a look at a sample of Qakbot also known as Qbot. You can see the implementation of the CPUID check in the sample by comparing the ECX register to see if it is equal to one. 

![image](https://user-images.githubusercontent.com/95584654/151471279-fb0d3966-3c34-489d-b01e-5c97142ade04.png)

### Memory Checks

The next anti-analysis check we will be looking at is basic memory checks. When malware researchers set up detention boxes, they usually allocate a low amount of resources to the box given all that it is doing is detonating a malware sample for dynamic analysis. In some cases, malware authors implement hardware checks to view information about the allocated resources of a computer. A common anti-analysis method is to check for the allocated amount of memory. The reason for this as mentioned above is that researchers will usually only allocate a very small amount of resources for their detention boxes.  Some functions of interest might have to do with querying system information such as GetSystemInfo() and or GetNativeSystemInfo(). For this section of the writeup, we will be looking at GlobalMemoryStatusEx().  

![image](https://user-images.githubusercontent.com/95584654/151478521-92f377c8-e43c-4cd6-bc44-67b0e140e9cc.png)

Alright, let's dig into this a little more. You can see from the screenshot above, that we make a call to GlobalMemoryStatusEx(). MSDN explains that this function retrieves information about the system's current usage of both physical and virtual memory. Let's take a look at the syntax of the function.
```C++
BOOL GlobalMemoryStatusEx(
  [in, out] LPMEMORYSTATUSEX lpBuffer
);
```
[in, out] lpBuffer

A pointer to a MEMORYSTATUSEX structure that receives information about current memory availability.

Let's now look at where this is used later in this anti-analysis function. We can see that the pointer is then used in this conditional check (See screenshot below) to see if the total physical memory is less than or greater than 2 gigabytes as 0x7D2B7500 in hex is 2100000000. You can see that if it is less than, it will call sleep for 10,000 ms, and if it is greater than, then it will continue execution flow.

![image](https://user-images.githubusercontent.com/95584654/151479167-6761606c-830b-42b8-b3e4-9c4ed412a65e.png)


### Virtual Port Checks

The next anti-analysis check we will be looking at has to do with querying information about the virtual I/O port. There are two main values to look for when trying to identify this. The first one is 0x5658 which is "VX" in ASCII and then the second one is 0×564D5868 which is "VMXh" in ASCII. It is possible for malware samples to detect / query information regarding the Virtual I/O ports. Let's take a look at a sample now.

![image](https://user-images.githubusercontent.com/95584654/151684472-76fb7a32-cb42-4861-a22c-65e38a7cc939.png)

In the sample above, you can see that a1 which is treated as an argument for this function and is checked to see if the value matches 0×564D5868 or "VMXh". If a1 is equal to that, variable v4 will be set to the value of 110. When looking at the cross-references to this function sub_4033FC, it is the first check-in the function sub_403EF7 which handles all of the anti-analysis functions



### File Checks


